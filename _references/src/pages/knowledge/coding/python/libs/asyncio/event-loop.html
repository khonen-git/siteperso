<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/src/assets/css/main.css">
    <script src="/src/assets/js/scripts.js"></script>
    <script src="/src/assets/js/knowledge/data-analytics/mathematics/probabilities/probability-distributions/continuous-probability-distributions/normal-distribution.js"></script>
    <link rel="stylesheet" href="/src/assets/lib/katex/katex.css">
    <script src="/src/assets/lib/katex/katex.js"></script>
    <title>Votre Nom - Data Analyst</title>
</head>
<body>
    <nav class="header-menu">
        <ul class="header-menu__list">
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/index.html">Accueil</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/about.html">À Propos</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/knowledge/index.html">Connaissances</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/projects/index.html">Projets Réalisés</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/contact.html">Contact</a>
            </li>
        </ul>
    </nav>
    
    <div class="knowledge-container">
        
        <iframe class="knowledge-iframe" src="/src/knowledge/utils/knowledge-nav.html"></iframe>
    
        <main class="knowledge-content">
            <section id="python-asyncio__introduction">
                <h1>Boucle d'événements</h1>
                <p>
                    La boucle d'événements (event loop) est un concept central dans asyncio et dans la programmation asynchrone en général. Elle exécute des opérations asynchrones, gère les événements réseau et planifie les tâches. Voici une explication avec des exemples de code pour illustrer son fonctionnement.
                </p>
            </section>
            <section id="python-asyncio__keys-concepts">
                <h2>Fonctionnement Basique de la Boucle d'Événements</h2>
                <p>
                    La boucle d'événements est chargée d'exécuter des coroutines et de gérer les opérations asynchrones.
                </p>
                <pre><code>
import asyncio

async def say_hello():
    print("Bonjour")
    await asyncio.sleep(1)
    print("Au revoir")

# Démarrer la boucle d'événements et exécuter la coroutine
asyncio.run(say_hello())                                                                                         
                </code></pre>
                <p>
                    Dans cet exemple, asyncio.run() démarre la boucle d'événements, qui exécute la coroutine say_hello().
                </p>
                <h2>Gestion Manuelle de la Boucle d'Événements</h2>
                <p>
                    Dans certains cas, il est préférable de gérer la boucle d'événements manuellement. Par exemple, lors de l'intégration avec certaines bibliothèques ou pour des contrôles plus avancés.
                </p>
                <pre><code>
loop = asyncio.get_event_loop()  # Obtention de la boucle d'événements

try:
    loop.run_until_complete(say_hello())  # Exécuter la coroutine dans la boucle
finally:
    loop.close()  # Toujours fermer la boucle proprement                    
                </code></pre>
                <p>
                    Ici, loop.run_until_complete() est utilisé pour exécuter la coroutine say_hello() dans la boucle d'événements.
                </p>
                <h2>Planification de Tâches dans la Boucle d'Événements</h2>
                <p>
                    Il est possible de planifier l'exécution de coroutines à différents moments ou après certains délais.
                </p>
                <pre><code>
async def delayed_message(delay, message):
    await asyncio.sleep(delay)
    print(message)

async def main():
    loop = asyncio.get_running_loop()

    # Planifier l'exécution de coroutines
    loop.create_task(delayed_message(2, "Message après 2 secondes"))
    loop.create_task(delayed_message(1, "Message après 1 seconde"))

    # Attendre que toutes les tâches soient complétées
    await asyncio.sleep(3)

asyncio.run(main())                                                         
                </code></pre>
                <p>
                    Dans ce cas, deux coroutines delayed_message sont planifiées pour s'exécuter après des délais spécifiques.
                </p>
                <h2>Utilisation de Callbacks</h2>
                <p>
                    La boucle d'événements peut également être utilisée pour exécuter des fonctions de rappel (callbacks).
                </p>
                <pre><code>
def simple_callback():
    print("Callback exécuté")

async def main():
    loop = asyncio.get_running_loop()

    # Planifier l'exécution du callback
    loop.call_soon(simple_callback)

asyncio.run(main())
                </code></pre>
                <p>
                    Le call_soon planifie l'exécution du callback simple_callback dès que possible dans la boucle d'événements.
                </p>
            </section>
        </main>
    </div>

    <footer>
        <p><a href="/src/credits.html">Crédits</a> | <a href="/src/contact.html">Contact</a> | <a href="/src/curriculum-vitae.html">Curriculum vitae</a></p>
    </footer>
    
</body>
</html>
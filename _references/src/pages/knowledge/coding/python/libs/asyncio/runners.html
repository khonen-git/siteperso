<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/src/assets/css/main.css">
    <script src="/src/assets/js/scripts.js"></script>
    <script src="/src/assets/js/knowledge/data-analytics/mathematics/probabilities/probability-distributions/continuous-probability-distributions/normal-distribution.js"></script>
    <link rel="stylesheet" href="/src/assets/lib/katex/katex.css">
    <script src="/src/assets/lib/katex/katex.js"></script>
    <title>Votre Nom - Data Analyst</title>
</head>
<body>
    <nav class="header-menu">
        <ul class="header-menu__list">
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/index.html">Accueil</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/about.html">À Propos</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/knowledge/index.html">Connaissances</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/projects/index.html">Projets Réalisés</a>
            </li>
            <li class="header-menu__item">
                <a class="header-menu__link" href="/src/contact.html">Contact</a>
            </li>
        </ul>
    </nav>
    
    <div class="knowledge-container">
        
        <iframe class="knowledge-iframe" src="/src/knowledge/utils/knowledge-nav.html"></iframe>
    
        <main class="knowledge-content">
            <section id="python-asyncio__introduction">
                <h1>Exécuteurs (runners)</h1>
                <p>
                    Les exécuteurs (runners) dans asyncio sont des composants qui gèrent la boucle d'événements et orchestrent l'exécution des coroutines. Ils jouent un rôle central dans la mise en œuvre de la concurrence asynchrone dans un programme asyncio.
                </p>
            </section>
            <section id="python-asyncio__keys-concepts">
                <h2>Exécution d'une Coroutine Simple</h2>
                <p>
                    Pour exécuter une coroutine, on utilise souvent asyncio.run(). Cette fonction prend une coroutine, la lance, et gère la boucle d'événements jusqu'à ce que la coroutine soit terminée.
                </p>
                <pre><code>
import asyncio

async def main():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

asyncio.run(main())                    
                </code></pre>
                <p>
                    Dans cet exemple, asyncio.run(main()) démarre la boucle d'événements, exécute la coroutine main, attend une seconde avec await asyncio.sleep(1), puis reprend et termine l'exécution de main.
                </p>
                <h2>Utilisation de la Boucle d'Événements Directement</h2>
                <p>
                    Il est aussi possible de gérer la boucle d'événements soi-même. Cela peut être utile pour des cas d'utilisation plus avancés, comme l'intégration avec des bibliothèques qui nécessitent un contrôle plus fin de la boucle.
                </p>
                <pre><code>
async def main():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main())
finally:
    loop.close()                
                </code></pre>
                <p>
                    Ici, loop.run_until_complete(main()) lance l'exécution de main et loop.close() ferme la boucle une fois que main a terminé.
                </p>
                <h2>Exécuteurs pour les Tâches Bloquantes</h2>
                <p>
                    Asyncio fournit un moyen d'exécuter des fonctions bloquantes de manière asynchrone en utilisant des exécuteurs. Cela est souvent utilisé pour intégrer du code synchrone qui bloque (comme les opérations d'entrée/sortie) dans une application asyncio.
                </p>
                <pre><code>
import asyncio
import concurrent.futures

def blocking_io():
    # Simule une opération bloquante
    with open('/path/to/file', 'r') as f:
        return f.read()

async def main():
    loop = asyncio.get_running_loop()

    # Exécute dans le ThreadPoolExecutor par défaut
    result = await loop.run_in_executor(None, blocking_io)
    print(result)

asyncio.run(main())
                </code></pre>
                <p>
                    Dans cet exemple, loop.run_in_executor(None, blocking_io) exécute la fonction blocking_io dans un pool de threads, permettant à la coroutine main de continuer à s'exécuter de manière asynchrone pendant que blocking_io est en cours.
                </p>
            </section>
        </main>
    </div>

    <footer>
        <p><a href="/src/credits.html">Crédits</a> | <a href="/src/contact.html">Contact</a> | <a href="/src/curriculum-vitae.html">Curriculum vitae</a></p>
    </footer>
    
</body>
</html>
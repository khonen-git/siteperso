<!DOCTYPE html>
<html>
<head>
	<title>Python - Structures de contrôle de flux</title>
	<meta charset="utf-8">
	<link rel="stylesheet" href="C:\Users\Utilisateur\VSrepos\SitePerso\css\style.css">
</head>
<body>
	<header>
		<nav>
		  <ul>
			<li><a href="C:\Users\Utilisateur\VSrepos\SitePerso\html\index.html">Accueil</a></li>
			<li><a href="C:\Users\Utilisateur\VSrepos\SitePerso\html\cours.html">Cours</a></li>
			<li><a href="C:\Users\Utilisateur\VSrepos\SitePerso\html\projets.html">Projets</a></li>
			<li><a href="C:\Users\Utilisateur\VSrepos\SitePerso\html\contact.html">Contact</a></li>
		  </ul>
		</nav>
	</header>

	<main>
		<h2>Structures de contrôle de flux en Python</h2>

		<section>
			<h3>Instructions conditionnelles</h3>
			<p>Les instructions conditionnelles permettent d'exécuter une partie de code uniquement si une condition est vraie.</p>
			<p>La syntaxe est la suivante :</p>
			<pre><code>if condition_1:
    # instructions à exécuter si condition_1 est vraie
elif condition_2:
    # instructions à exécuter si condition_1 est fausse et condition_2 est vraie
else:
    # instructions à exécuter si toutes les conditions précédentes sont fausses</code></pre>
		</section>

		<section>
			<h3>Boucles</h3>
			<p>Les boucles permettent d'exécuter une partie de code plusieurs fois.</p>
			<p>La boucle <code>while</code> exécute le code tant qu'une condition est vraie. La boucle <code>for</code> parcourt une séquence d'éléments et exécute le code pour chaque élément.</p>
			<p>La syntaxe est la suivante :</p>
			<pre><code># boucle while
while condition:
    # instructions à exécuter tant que la condition est vraie
  
# boucle for
for element in sequence:
    # instructions à exécuter pour chaque élément de la séquence</code></pre>
		</section>

		<section>
			<h3>Instructions de contrôle de boucle</h3>
			<p>Les instructions de contrôle de boucle permettent de modifier le comportement d'une boucle.</p>
			<p><code>break</code> permet de sortir immédiatement de la boucle, tandis que <code>continue</code> permet de passer à l'itération suivante.</p>
		</section>

		<section>
			<h3>Expressions booléennes</h3>
			<p>Les expressions booléennes permettent de combiner des conditions.</p>
			<p><code>and</code> renvoie <code>True</code> si les deux conditions sont vraies, <code>or</code> renvoie <code>True</code> si au moins une des conditions est vraie, <code>not</code> inverse le résultat de la condition.</p>
		</section>

		<section>
			<h3>Comparaisons</h3>
			<p>Les comparaisons permettent de comparer des valeurs.</p>
            <p><code>==</code> teste si les deux valeurs sont égales, <code>!=</code> teste si les deux valeurs sont différentes, <code>&lt;</code> et <code>&gt;</code> testent si la première valeur est inférieure ou supérieure à la deuxième, <code>&lt;=</code> et <code>&gt;=</code> testent si la première valeur est inférieure ou égale, ou supérieure ou égale, à la deuxième.</p>
        </section>
    
        <section>
            <h3>Opérateurs d'appartenance</h3>
            <p>Les opérateurs d'appartenance permettent de tester si une valeur est présente dans une séquence.</p>
            <p><code>in</code> renvoie <code>True</code> si la valeur est présente, <code>not in</code> renvoie <code>True</code> si la valeur n'est pas présente.</p>
        </section>
    
        <section>
            <h3>Opérateurs d'identité</h3>
            <p>Les opérateurs d'identité permettent de tester
                <p>si deux variables ont la même identité.</p>
                <p><code>is</code> renvoie <code>True</code> si les deux variables ont la même identité, <code>is not</code> renvoie <code>True</code> si les deux variables ont des identités différentes.</p>
            </section>
        
            <section>
                <h3>Règles de précédence des opérateurs</h3>
                <p>Les opérateurs sont évalués dans un ordre déterminé appelé règle de précédence. Si nécessaire, on peut utiliser des parenthèses pour modifier l'ordre d'évaluation.</p>
                <p>Voici les règles de précédence des opérateurs (du plus haut au plus bas) :</p>
                <ol>
                    <li>Parenthèses</li>
                    <li>Opérateurs unaires (<code>not</code>, <code>+</code>, <code>-</code>)</li>
                    <li>Opérateurs binaires (<code>**</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>)</li>
                    <li>Opérateurs binaires (<code>+</code>, <code>-</code>)</li>
                    <li>Opérateurs binaires de comparaison (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code>)</li>
                    <li>Opérateurs binaires logiques (<code>and</code>, <code>or</code>)</li>
                    <li>Opérateurs d'affectation (<code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, etc.)</li>
                </ol>
            </section>
        </main>
        
        <footer>
					<p>© 2023 Théo CHarron</p>
				</footer>
    </body>
</html>